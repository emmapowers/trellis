"""Workspace utilities and code generation for bundle building.

Provides workspace management and generates the _registry.ts wiring file
that connects all registered modules together.
"""

from __future__ import annotations

from pathlib import Path

from jinja2 import Template

from trellis.bundler.registry import CollectedModules, ExportKind

# JavaScript/TypeScript extensions to strip from import paths
JS_EXTENSIONS = (".tsx", ".ts", ".jsx", ".js")

# Template for generating _registry.ts
_REGISTRY_TS_TEMPLATE = Template(
    """\
// Auto-generated by trellis bundler
{% if components %}

import { registerWidget } from "@trellis/trellis-core/widgets/index";
{% endif %}
{% if initializers %}
{% for module, source in initializers %}
import "@trellis/{{ module }}/{{ source }}";
{% endfor %}
{% endif %}
{% if stylesheets %}
{% for module, source in stylesheets %}
import "@trellis/{{ module }}/{{ source }}";
{% endfor %}
{% endif %}
{% if components %}
{% for name, module, source in components %}
import { {{ name }} } from "@trellis/{{ module }}/{{ source }}";
{% endfor %}
{% endif %}
{% if functions %}
{% for name, module, source in functions %}
import { {{ name }} } from "@trellis/{{ module }}/{{ source }}";
{% endfor %}

export { {{ functions | map(attribute=0) | join(', ') }} };
{% endif %}

export function initRegistry(): void {
{% for name, module, source in components %}
  registerWidget("{{ name }}", {{ name }});
{% endfor %}
}
"""
)


def node_modules_path(workspace: Path) -> Path:
    """Return the node_modules path for a workspace."""
    return workspace / "node_modules"


def get_workspace_dir() -> Path:
    """Get the workspace directory for the application.

    Returns:
        Path to {app_root}/.workspace

    Raises:
        RuntimeError: If set_apploader() has not been called
    """
    # Late import to avoid circular dependency (workspace.py is imported during
    # module initialization, but get_app_root is only called at runtime)
    from trellis.app.apploader import get_app_root  # noqa: PLC0415

    return get_app_root() / ".workspace"


def get_dist_dir() -> Path:
    """Get the output directory for built bundles.

    Returns:
        Path to {app_root}/.dist

    Raises:
        RuntimeError: If set_apploader() has not been called
    """
    # Late import to avoid circular dependency
    from trellis.app.apploader import get_app_root  # noqa: PLC0415

    return get_app_root() / ".dist"


def write_registry_ts(workspace: Path, collected: CollectedModules) -> Path:
    """Generate and write the _registry.ts wiring file.

    Creates the workspace directory if needed and writes _registry.ts.

    Args:
        workspace: Workspace directory to write to
        collected: Collected modules with exports to register

    Returns:
        Path to the written _registry.ts file
    """
    workspace.mkdir(parents=True, exist_ok=True)
    registry_path = workspace / "_registry.ts"
    registry_code = generate_registry_ts(collected)
    registry_path.write_text(registry_code)
    return registry_path


def generate_registry_ts(collected: CollectedModules) -> str:
    """Generate the _registry.ts wiring file.

    This file:
    - Imports all component exports and registers them via registerWidget()
    - Imports all initializer exports for their side effects
    - Re-exports all function exports
    - Exports an initRegistry() function that registers all components

    Args:
        collected: Collected modules

    Returns:
        TypeScript code for _registry.ts
    """
    components: list[tuple[str, str, str]] = []  # (name, module, source)
    functions: list[tuple[str, str, str]] = []  # (name, module, source)
    initializers: list[tuple[str, str]] = []  # (module, source)
    stylesheets: list[tuple[str, str]] = []  # (module, source)

    for module in collected.modules:
        for export in module.exports:
            # Remove JS/TS extensions for import path (but keep .css)
            source_path = export.source
            for ext in JS_EXTENSIONS:
                if source_path.endswith(ext):
                    source_path = source_path.removesuffix(ext)
                    break

            if export.kind == ExportKind.COMPONENT:
                components.append((export.name, module.name, source_path))
            elif export.kind == ExportKind.FUNCTION:
                functions.append((export.name, module.name, source_path))
            elif export.kind == ExportKind.INITIALIZER:
                initializers.append((module.name, source_path))
            elif export.kind == ExportKind.STYLESHEET:
                stylesheets.append((module.name, export.source))

    return _REGISTRY_TS_TEMPLATE.render(
        components=components,
        functions=functions,
        initializers=initializers,
        stylesheets=stylesheets,
    )
