"""Workspace staging and code generation for bundle building.

Stages registered modules into a project-specific workspace and generates
the _registry.ts wiring file that connects everything together.
"""

from __future__ import annotations

import hashlib
import json
import shutil
from pathlib import Path

from .registry import CollectedModules, ExportKind


def get_project_hash(entry_point: Path) -> str:
    """Get a hash identifying a project based on its entry point path.

    Args:
        entry_point: Path to the project's entry point file

    Returns:
        A short hash string identifying this project
    """
    path_str = str(entry_point.resolve())
    return hashlib.sha256(path_str.encode()).hexdigest()[:16]


def get_project_workspace(entry_point: Path) -> Path:
    """Get the workspace directory for a project.

    The workspace is a cache directory identified by a hash of the entry point path.
    This ensures each project gets its own isolated build workspace.

    Args:
        entry_point: Path to the project's entry point file

    Returns:
        Path to the project's workspace directory (created if needed)
    """
    cache_dir = Path.home() / ".cache" / "trellis" / "projects"
    project_hash = get_project_hash(entry_point)
    workspace = cache_dir / project_hash
    workspace.mkdir(parents=True, exist_ok=True)
    return workspace


def stage_workspace(
    workspace: Path,
    collected: CollectedModules,
    entry_point: Path,
) -> None:
    """Stage all modules into a workspace directory.

    Creates the following structure:
        workspace/
            staged/
                module-name/
                    ... files and snippets
            entry.tsx
            _registry.ts

    Args:
        workspace: Root workspace directory
        collected: Collected modules to stage
        entry_point: Entry point file to copy
    """
    staged_dir = workspace / "staged"
    staged_dir.mkdir(parents=True, exist_ok=True)

    # Stage each module
    for module in collected.modules:
        module_dir = staged_dir / module.name
        module_dir.mkdir(parents=True, exist_ok=True)

        # Copy files from module's base path
        if module._base_path:
            for file_path in module.files:
                src = module._base_path / file_path
                dst = module_dir / file_path
                dst.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(src, dst)

        # Write snippets as files
        for filename, code in module.snippets.items():
            dst = module_dir / filename
            dst.parent.mkdir(parents=True, exist_ok=True)
            dst.write_text(code)

    # Copy entry point to workspace root
    workspace_entry = workspace / "entry.tsx"
    shutil.copy2(entry_point, workspace_entry)

    # Generate and write _registry.ts
    registry_code = generate_registry_ts(collected)
    (staged_dir / "_registry.ts").write_text(registry_code)

    # Generate and write tsconfig.json
    tsconfig = generate_tsconfig(collected)
    (workspace / "tsconfig.json").write_text(tsconfig)


def generate_registry_ts(collected: CollectedModules) -> str:
    """Generate the _registry.ts wiring file.

    This file:
    - Imports all component exports and registers them via registerWidget()
    - Imports all initializer exports for their side effects
    - Re-exports all function exports
    - Exports an initRegistry() function that registers all components

    Args:
        collected: Collected modules

    Returns:
        TypeScript code for _registry.ts
    """
    lines: list[str] = ["// Auto-generated by trellis bundler", ""]

    # Collect exports by kind
    component_imports: list[tuple[str, str, str]] = []  # (name, module, source)
    function_imports: list[tuple[str, str, str]] = []  # (name, module, source)
    initializer_imports: list[tuple[str, str]] = []  # (module, source)

    for module in collected.modules:
        for export in module.exports:
            # Remove .tsx/.ts extension for import path
            source_path = export.source
            if source_path.endswith(".tsx"):
                source_path = source_path[:-4]
            elif source_path.endswith(".ts"):
                source_path = source_path[:-3]

            if export.kind == ExportKind.component:
                component_imports.append((export.name, module.name, source_path))
            elif export.kind == ExportKind.function:
                function_imports.append((export.name, module.name, source_path))
            elif export.kind == ExportKind.initializer:
                initializer_imports.append((module.name, source_path))

    # Import registerWidget if we have components
    if component_imports:
        lines.append('import { registerWidget } from "@trellis/trellis-core/widgets/index";')
        lines.append("")

    # Import initializers (side-effect imports)
    for module_name, source_path in initializer_imports:
        lines.append(f'import "@trellis/{module_name}/{source_path}";')

    if initializer_imports:
        lines.append("")

    # Import components
    for name, module_name, source_path in component_imports:
        lines.append(f'import {{ {name} }} from "@trellis/{module_name}/{source_path}";')

    if component_imports:
        lines.append("")

    # Import functions
    for name, module_name, source_path in function_imports:
        lines.append(f'import {{ {name} }} from "@trellis/{module_name}/{source_path}";')

    if function_imports:
        lines.append("")

    # Re-export functions
    if function_imports:
        func_names = [name for name, _, _ in function_imports]
        lines.append(f"export {{ {', '.join(func_names)} }};")
        lines.append("")

    # Generate initRegistry function
    lines.append("export function initRegistry(): void {")
    for name, _, _ in component_imports:
        lines.append(f'  registerWidget("{name}", {name});')
    lines.append("}")
    lines.append("")

    return "\n".join(lines)


def generate_tsconfig(collected: CollectedModules) -> str:
    """Generate tsconfig.json with path aliases for IDE support.

    Args:
        collected: Collected modules

    Returns:
        JSON string for tsconfig.json
    """
    paths: dict[str, list[str]] = {
        "@trellis/_registry": ["./staged/_registry.ts"],
    }

    for module in collected.modules:
        paths[f"@trellis/{module.name}/*"] = [f"./staged/{module.name}/*"]

    config = {
        "compilerOptions": {
            "target": "ES2022",
            "module": "ESNext",
            "moduleResolution": "bundler",
            "jsx": "react-jsx",
            "strict": True,
            "esModuleInterop": True,
            "skipLibCheck": True,
            "baseUrl": ".",
            "paths": paths,
        },
        "include": ["staged/**/*", "entry.tsx"],
    }

    return json.dumps(config, indent=2) + "\n"
